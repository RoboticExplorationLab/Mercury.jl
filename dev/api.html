<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Mercury.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Mercury.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This page is a dump of all the docstrings found in the code. This will be cleaned up in the future and organized to be more accessible.</p><article class="docstring"><header><a class="docstring-binding" id="Mercury.LoopRateLimiter" href="#Mercury.LoopRateLimiter"><code>Mercury.LoopRateLimiter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LoopRateLimiter</code></pre><p>Runs a loop at a fixed rate. Works best for loops where the runtime is approximately the same every iteration. The loop runtime is kept approximately constant by sleeping for any time not used by the core computation. This is useful for situations where the computation should take place a regular, predictable intervals.</p><p>To achieve better accuracy, the rate limiter records the error between the expected runtime and actual runtime every <code>N_batch</code> iterations, and adjusts the sleep time by the average. Unlike the standard sleep function in Julia, this limiter has a minimum sleep time of 1 microsecond, and rates above 1000Hz can be achieved with moderate accuracy.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">lrl = LoopRateLimiter(100)  # Hz
reset!(lrl)
for i = 1:100
    startloop(lrl)          # start timing the loop
    myexpensivefunction()   # execute the core body of the loop
    sleep(lrl)              # sleep for the rest of the time
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/rate_limiter.jl#L10-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.Node" href="#Mercury.Node"><code>Mercury.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Node</code></pre><p>A independent process that communicates with other processes via pub/sub ZMQ channels. The process is assumed to run indefinately.</p><p><strong>Defining a new Node</strong></p><p>Each node should contain a <code>NodeData</code> element, which stores a list of the publishers and subscribers and some other associated data.</p><p>The publisher and subscribers for the node should be &quot;registered&quot; with the <code>NodeData</code> using the <code>add_publisher!</code> and <code>add_subscriber!</code> methods. This allows the subscribers to be automatically launched as separate tasks when launching the nodes.</p><p>The constructor for the node should initialize any variables and register the needed publishers and subscribers with <code>NodeData</code>.</p><p>Each loop of the process will call the <code>compute</code> method once, which needs to be implemented by the user. A lock for each subscriber task is created in <code>NodeData.sub_locks</code>. It&#39;s recommended that the user obtains the lock and copies the data into a local variable for internal use by the <code>compute</code> function.</p><p><strong>Launching the node</strong></p><p>The blocking process that runs the node indefinately is called via <code>run(node)</code>. It&#39;s recommended that this is launched asynchronously via</p><pre><code class="nohighlight hljs">node_task = @task run(node)
schedule(node_task)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L132-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.NodeIO" href="#Mercury.NodeIO"><code>Mercury.NodeIO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeIO</code></pre><p>Describes the input/output mechanisms for the node. Each node should store this type internally and add the necessary I/O mechanisms inside of the <code>setupIO!(::NodeIO, ::Node)</code> method.</p><p>I/O mechanisms are added to a <code>NodeIO</code> object via <a href="api.html#Mercury.add_publisher!-Tuple{Mercury.NodeIO, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}, Mercury.Publisher}"><code>add_publisher!</code></a> and <a href="api.html#Mercury.add_subscriber!-Tuple{Mercury.NodeIO, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}, Mercury.Subscriber}"><code>add_subscriber!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.PublishedMessage" href="#Mercury.PublishedMessage"><code>Mercury.PublishedMessage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Specifies a publisher along with specific message type. This is useful for tracking multiple messages at once</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/publishers/abstract_publisher.jl#L48-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.SubscribedMessage" href="#Mercury.SubscribedMessage"><code>Mercury.SubscribedMessage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Specifies a subcriber along with specific message type. This is useful for tracking multiple messages at once</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L85-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.SubscriberFlags" href="#Mercury.SubscriberFlags"><code>Mercury.SubscriberFlags</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubscriberFlags</code></pre><p>Some useful flags when dealing with subscribers. Describes the state of the system. Particularly helpful when the subscriber is actively receiving messages in another thread and you want to query the state of the subscriber.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.ZmqPublisher" href="#Mercury.ZmqPublisher"><code>Mercury.ZmqPublisher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Publisher</code></pre><p>A simple wrapper around a ZMQ publisher, but only publishes protobuf messages.</p><p><strong>Construction</strong></p><pre><code class="nohighlight hljs">Publisher(context::ZMQ.Context, ipaddr, port; name)</code></pre><p>To create a publisher, pass in a <code>ZMQ.Context</code>, which allows all related publisher / subscribers to be collected in a &quot;group.&quot; The publisher also needs to be provided the IPv4 address (either as a string or as a <code>Sockets.IPv4</code> object), and the port (either as an integer or a string).</p><p>A name can also be optionally provided via the <code>name</code> keyword, which can be used to provide a helpful description about what the publisher is publishing. It defaults to &quot;publisher_#&quot; where <code>#</code> is an increasing index.</p><p>If the port</p><p><strong>Usage</strong></p><p>To publish a message, just use the <code>publish</code> method on a protobuf type:</p><pre><code class="nohighlight hljs">publish(pub::Publisher, proto_msg::ProtoBuf.ProtoType)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/publishers/zmq_publisher.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.ZmqSubscriber" href="#Mercury.ZmqSubscriber"><code>Mercury.ZmqSubscriber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZmqSubscriber</code></pre><p>A simple wrapper around a ZMQ subscriber, but only for protobuf messages.</p><p><strong>Construction</strong></p><pre><code class="nohighlight hljs">Subscriber(context::ZMQ.Context, ipaddr, port; name)</code></pre><p>To create a subscriber, pass in a <code>ZMQ.Context</code>, which allows all related publisher / subscribers to be collected in a &quot;group.&quot; The subscriber also needs to be provided the IPv4 address (either as a string or as a <code>Sockets.IPv4</code> object), and the port (either as an integer or a string).</p><p>A name can also be optionally provided via the <code>name</code> keyword, which can be used to provide a helpful description about what the subscriber is subscribing to. It defaults to &quot;subscriber_#&quot; where <code>#</code> is an increasing index.</p><p><strong>Usage</strong></p><p>Use the blocking <code>subscribe</code> method to continually listen to the socket and store data in a protobuf type:</p><pre><code class="nohighlight hljs">subscribe(sub::Subscriber, proto_msg::ProtoBuf.ProtoType)</code></pre><p>Note that this function contains an infinite while loop so will block the calling thread indefinately. It&#39;s usually best to assign the process to a separate thread / task:</p><pre><code class="nohighlight hljs">sub_task = @task subscribe(sub, proto_msg)
schedule(sub_task)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/zmq_subscriber.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sleep-Union{Tuple{Mercury.LoopRateLimiter{UseSleep}}, Tuple{UseSleep}} where UseSleep" href="#Base.sleep-Union{Tuple{Mercury.LoopRateLimiter{UseSleep}}, Tuple{UseSleep}} where UseSleep"><code>Base.sleep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sleep(::LoopRateLimiter)</code></pre><p>Sleep the OS for the amount of time needed to achieve the rate specified by the loop rate limiter. Has a minimum sleep time of 1 microsecond (relies on the <code>usleep</code> C function).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/rate_limiter.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.add_publisher!-Tuple{Mercury.NodeIO, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}, Mercury.Publisher}" href="#Mercury.add_publisher!-Tuple{Mercury.NodeIO, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}, Mercury.Publisher}"><code>Mercury.add_publisher!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_publisher!(nodeIO, msg, args...)</code></pre><p>Adds / registers a publisher to <code>nodeIO</code>. This method should only be called once per unique message, across all nodes in the network, since each message should only ever have one publisher. The <code>msg</code> can be any <code>ProtoBuf.ProtoType</code> message (usually generated using <code>ProtoBuf.protoc</code>). Since this is stored as an abstract <code>ProtoBuf.ProtoType</code> type internally, the user should store the original type inside the node.  The remaining arguments are passed directly to the constructor for <a href="@ref"><code>Publisher</code></a>.</p><p>This function adds a new <a href="api.html#Mercury.PublishedMessage"><code>PublishedMessage</code></a> to <code>nodeIO.pubs</code>. During the <code>compute</code>     method, the user should modify the original concrete <code>msg</code> stored in the node. The     data can then be published by calling <code>publish</code> on the corresponding <code>PublishedMessage</code>.</p><p><strong>Example</strong></p><p>Inside of the node constructor:</p><pre><code class="nohighlight hljs">...
test_msg = TestMsg(x = 1, y = 2, z= 3)
...</code></pre><p>Inside of <code>setupIO!</code>:</p><pre><code class="nohighlight hljs">...
ctx = ZMQ.Context()
ipaddr = ip&quot;127.0.0.1&quot;
port = 5001
add_publisher!(nodeIO, node.test_msg, ctx, ipaddr, port, name=&quot;TestMsg_publisher&quot;)
...</code></pre><p>Inside of <code>compute</code>:</p><pre><code class="nohighlight hljs">...
node.test_msg.x = 1  # modify the message as desired
publish(getIO(node).pubs[1])  # or whichever is the correct index
...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L40-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.add_subscriber!-Tuple{Mercury.NodeIO, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}, Mercury.Subscriber}" href="#Mercury.add_subscriber!-Tuple{Mercury.NodeIO, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}, Mercury.Subscriber}"><code>Mercury.add_subscriber!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_subscriber!(nodeIO, msg, args...)</code></pre><p>Adds / registers a subscriber to <code>nodeIO</code>. The <code>msg</code> can be any <code>ProtoBuf.ProtoType</code> message (usually generated using <code>ProtoBuf.protoc</code>). Since this is stored as an abstract <code>ProtoBuf.ProtoType</code> type internally, the user should store the original type inside the node.  The remaining arguments are passed directly to the constructor for <a href="@ref"><code>Subscriber</code></a>.</p><p>This function adds a new <a href="api.html#Mercury.SubscribedMessage"><code>SubscribedMessage</code></a> to <code>nodeIO.subs</code>. A separate asynchronous task is created for each subscriber when the node is launched.  During the <code>compute</code> method, the user can access the latest data by reading from the message stored in their node. To avoid data races and minimize synchronization, it&#39;s usually best practice to obtain the lock on the message (stored in <code>SubscribedMessage</code>) and copy the data to a local variable (likely also stored in the node) that can be used by the rest of the <code>compute</code> method without worrying about the data being overwritted by the ongoing subscriber task.</p><p><strong>Example</strong></p><p>In the node constructor:</p><pre><code class="nohighlight hljs">...
test_msg = TestMessage(x = 0, y = 0, z = 0)
...</code></pre><p>In <code>setupIO!</code>:</p><pre><code class="nohighlight hljs">...
ctx = ZMQ.Context()
ipaddr = ip&quot;127.0.0.1&quot;
port = 5001
add_subscriber!(nodeIO, node.test_msg, ctx, ipaddr, port, name = &quot;TestMsg_subscriber&quot;)
...</code></pre><p>In <code>compute</code>:</p><pre><code class="nohighlight hljs">...
testmsg = getIO(node).subs[1]  # or whichever is the correct index
lock(testmsg.lock) do
    node.local_test_msg = node.test_msg  # or convert to a different type
end
# use node.local_test_msg in the rest of the code
...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L82-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.decode!-Tuple{ProtoBuf.ProtoType, IOBuffer}" href="#Mercury.decode!-Tuple{ProtoBuf.ProtoType, IOBuffer}"><code>Mercury.decode!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read in the byte data into the message container buf. Returns the number of bytes read</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.encode!-Tuple{ProtoBuf.ProtoType, IOBuffer}" href="#Mercury.encode!-Tuple{ProtoBuf.ProtoType, IOBuffer}"><code>Mercury.encode!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write out the byte data into the message container buf. Returns the number of bytes written</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/publishers/abstract_publisher.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.getpublisher" href="#Mercury.getpublisher"><code>Mercury.getpublisher</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpublisher(node, index)
getpublisher(node, name)</code></pre><p>Get a  <a href="api.html#Mercury.PublishedMessage"><code>PublishedMessage</code></a> attached to <code>node</code>, either by it&#39;s integer index or it&#39;s name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.getsubscriber" href="#Mercury.getsubscriber"><code>Mercury.getsubscriber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getsubscriber(node, index)
getsubscriber(node, name)</code></pre><p>Get a  <a href="api.html#Mercury.SubscribedMessage"><code>SubscribedMessage</code></a> attached to <code>node</code>, either by it&#39;s integer index or it&#39;s name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L244-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.got_new!-Tuple{Mercury.Subscriber}" href="#Mercury.got_new!-Tuple{Mercury.Subscriber}"><code>Mercury.got_new!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the has received flag on subscriber to true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.launch-Tuple{Mercury.Node}" href="#Mercury.launch-Tuple{Mercury.Node}"><code>Mercury.launch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">launch(node)</code></pre><p>Run the main loop of the node indefinately. This method automatically sets up any necessary subscriber tasks and then calls the <code>compute</code> method at a fixed rate.</p><p>This method should typically be wrapped in an <code>@async</code> or <code>@spawn</code> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L260-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.numpublishers" href="#Mercury.numpublishers"><code>Mercury.numpublishers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numpublishers(node)</code></pre><p>Get the number of ZMQ publishers attached to the node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.numsubscribers" href="#Mercury.numsubscribers"><code>Mercury.numsubscribers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numsubscribers(node)</code></pre><p>Get the number of ZMQ subscribers attached to the node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/node.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.on_new-Tuple{Function, Mercury.SubscribedMessage}" href="#Mercury.on_new-Tuple{Function, Mercury.SubscribedMessage}"><code>Mercury.on_new</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">on_new(func::Function, submsg::SubscribedMessage)</code></pre><p>Helpful function for executing code blocks when a SubscribedMessage type has recieved a new message on its Subscriber&#39;s Socket. The function func is expected to have a signature of <code>func(msg::ProtoBuf.ProtoType)</code> where msg is the message which <code>submsg</code> has recieved.</p><p>Example:</p><pre><code class="nohighlight hljs">on_new(nodeio.subs[1]) do msg
    println(msg.pos_x)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L121-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.publish_until_receive" href="#Mercury.publish_until_receive"><code>Mercury.publish_until_receive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">publish_until_receive(pub, sub, msg_out; [timeout])</code></pre><p>Publish a message via the publisher <code>pub</code> until it&#39;s received by the subscriber <code>sub</code>. Both <code>pub</code> and <code>sub</code> should have the same port and IP address.</p><p>The function returns <code>true</code> if a message was received before <code>timeout</code> seconds have passed,     and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/zmq_subscriber.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.read_new!-Tuple{Mercury.Subscriber}" href="#Mercury.read_new!-Tuple{Mercury.Subscriber}"><code>Mercury.read_new!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the has received flag on subscriber to false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L48-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.receive-Tuple{Mercury.Subscriber, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}}" href="#Mercury.receive-Tuple{Mercury.Subscriber, Union{ProtoBuf.ProtoType, AbstractVector{UInt8}}}"><code>Mercury.receive</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Receive function, is expected to return true if a message was received, false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/subscribers/abstract_subscriber.jl#L74-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.reset!-Tuple{Mercury.LoopRateLimiter}" href="#Mercury.reset!-Tuple{Mercury.LoopRateLimiter}"><code>Mercury.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset!(::LoopRateLimiter)</code></pre><p>Reset the loop rate limiter before a loop. Not necessary if the object is created directly before calling the loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/rate_limiter.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.startloop-Tuple{Mercury.LoopRateLimiter}" href="#Mercury.startloop-Tuple{Mercury.LoopRateLimiter}"><code>Mercury.startloop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startloop(::LoopRateLimiter)</code></pre><p>Call this function at the beginning of a loop body to start timing the loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/rate_limiter.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.usleep-Tuple{Any}" href="#Mercury.usleep-Tuple{Any}"><code>Mercury.usleep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">usleep(us)</code></pre><p>Sleep for <code>us</code> microseconds. A wrapper around the C <code>usleep</code> function in <code>unistd.h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/rate_limiter.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mercury.@rate-Tuple{Any, Any}" href="#Mercury.@rate-Tuple{Any, Any}"><code>Mercury.@rate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rate</code></pre><p>Run a loop at a fixed rate, specified either by an integer literal or a <code>LoopRateLimiter</code> object. It will run the loop so that it executes close to <code>rate</code> iterations per second.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@rate for i = 1:100
    myexpensivefunction()
end 200#Hz</code></pre><pre><code class="nohighlight hljs">lr = LoopRateLimiter(200, N_batch=10)
@rate while i &lt; 100
    myexpensivefunction()
    i += 1
end lr</code></pre><p>Note that the following does NOT work:</p><pre><code class="nohighlight hljs">rate = 100
@rate for i = 1:100
    myexpensivefunction()
end rate</code></pre><p>Since Julia macros dispatch on the compile-time types instead of the run-time types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/Mercury.jl/blob/013cfab3555cf1e88902ced07f3f773ce623f0b7/src/rate_limiter.jl#L130-L160">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 3 November 2021 14:54">Wednesday 3 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
